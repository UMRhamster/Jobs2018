* [一、数组与链表](#1)
  - [数组](#1.1)
  - [链表](#1.2)
  - [数组与链表的选择](#1.3)
* [二、哈希表](#2)
  - [Hash函数](#2.1)
  - [哈希碰撞](#2.2)
<h1 id="1">一、数组与链表</h1>
<h2 id="1.1">数组</h2>
在Java中，数组属于引用类型，继承了顶级类Object。
可以通过

    int[] nums = new int[]{0,1,0,3,12};
    nums.length;

以对象的方式获取到数组的长度，还可以调用Object类所拥有的方法。

数组在内存中用一组连续的存储单元存储数据，数组中的每个元素都对应于一组下标，数组中的素有元素必须属于同一数据类型。

![图片](https://github.com/UMRhamster/Jobs2018/raw/master/source_analyze/img/source_analyze_array.png)

* 创建数组时，必须声明数组的长度，并且数组在创建之后长度就固定了，不能对其大小进行动态修改。
* 可以通过下标对数组元素进行随机访问，并且其时间复杂度为O(1)。但是，对于查询，需要对数组进行遍历，所以时间复杂度为O(n)。
* 在进行数组元素的插入与删除时，效率是比较低的。因为，需要将插入位置以后的的所有元素一位，或将删除位置后的所有元素前移一位。这种移动是比较耗时的，特别是对于很长的数组。

### 数组的创建方式

    int [] array = {0,1,2,3};  //这种方式会自动分配对应元素数量的空间
    int[] array1 = new int[9];  //指明数组大小
    int array2 [] = new int[9];  //推荐使用第二种创建方式，可读性比较强 int[] 表示引用类型，而不是 int 类型。

### 数组中的length属性
首先可以确定Java数组中的length不是方法，（方法的表现形式应该为array.length()）。实际上length也不是属性。

Java对数组的操作是指令级的，在一个数组对象上调用length，会被Java编译器编译成一条arraylength指令（Java   binary   code）。

[java数组中的length属性到底属于java中的哪个类](https://blog.csdn.net/jayzym/article/details/76643527)

<h2 id="1.2">链表</h2>
链表是一种离散存储结构,用一组任意的存储单元存储数据（这些存储单元可以说是连续的，也可以是不连续的）。数据元素中的逻辑关系由节点中的指针指出,即每个数据元素都通过一个指针指向其下一个元素的地址。根据指针域的不同，链表又分为单链表、双向链表、循环链表等，这里我们只分析单链表。


![图片](https://github.com/UMRhamster/Jobs2018/raw/master/source_analyze/img/source_analyze_linked_list.png)

下面是链表中的节点，value代表节点的数据，next是指向下一个节点的引用

    public class ListNode {
        public int value;
        public ListNode next;
        public ListNode(int value){
            this.value = value;
        }
    }

* 声明链表时，不需要指明其长度，并且链表长度是可以动态变化的。
* 链表的节点分为数据域和指针域，数据域存放实际数据，指针域指向下一个节点。和数组相比，每个元素占用的内存更大，多一个引用所占用的空间。
* 因为链表不需要连续存储空间，所以不能进行随机访问，对于与第i个元素的访问，以及查询操作，都需要对链表进行遍历，时间复杂度为O(n)。
* 对于节点的插入和操作，链表表现较好，只需要在对应的节点处理next引用，就可以将一个节点删除或添加新节点。

<h2 id="1.3">数组与链表的选择</h2>

* 数组可以随机访问，但是插入和删除需要移动大量元素，比较耗时
* 链表对任意元素的访问都需要从头开始遍历，增加和删除比较方便，只需要修改元素引用。
* 数组创建之后大小固定，不可改变。链表大小可以动态调整。
* 数组需要连续内存空间，而链表不需要。
* 每个元素的内存占用上链表大于数组。

对与需要快速随机访问的场景，应该使用数组。对于频繁进行插入和删除操作的场景，应该使用链表。

<h1 id="2">哈希表</h1>
无论是数组还是链表,其查询效率都不是很高，都需要对数组或者链表进行遍历比较。我们没有办法直接通过元素知道它的存储位置。

一种有效的存储方式，是不与其他元素进行比较，一次存取便能得到所需要的记录。这就需要在对象的存储位置和对象的关键属性（设为 k）之间建立一个特定的对应关系（设为 f），使每个对象与一个唯一的存储位置相对应。在查找时，只要根据待查对象的关键属性 k 计算f(k)的值即可。按照这种思想建立的表为哈希表。
<h2 id="2.1">Hash函数</h2>
建立key值与value值映射关系的函数就是Hash函数。

Hash表其实就是一个数组，数组元素是包含key值与value值的实体。需要插入的元素通过Hash函数计算出存储位置后再插入。

![图片](https://github.com/UMRhamster/Jobs2018/raw/master/source_analyze/img/hash_table_hash_method.png)

<h2 id="2.2">哈希碰撞</h2>
然而通过Hash函数计算hash值，可能出现两个对象的hash值相同的情况,这就是发生了哈希碰撞。

哈希碰撞的解决方法：
* 开放定址法
* 链地址法
  
### 开放定址法
 
 当发生地址冲突时，按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止。公式表示如下：

 ![图片](https://github.com/UMRhamster/Jobs2018/raw/master/source_analyze/img/hash_table_open_addressing_formula.png)

 其中，H(key)是hash函数，m为哈希表的长度。

举例如下：

Hash函数：H(key) =  key mod 7;
哈希表长度为 7 ；
key值 序列为 23，13，49，55，22，38，21

  ![图片](https://github.com/UMRhamster/Jobs2018/raw/master/source_analyze/img/hash_table_open_addressing.png)

  首先通过Hash函数计算key值的hash值。
  32 mod 7 = 4，  13 mod 7 = 6，  49 mod 7 = 0，此时未发生哈希碰撞；

  当插入 55 时，计算其hash值，55 mod 7 = 6,发生冲突。下一个地址为(6+1) % 7 = 0，仍然发生冲突，再看下一个地址(6+2) % 7 = 1，未发生冲突，放入。

  22 mod 7 = 1，发生冲突，下一个地址为(1+1) % 7 = 2，未发生冲突，可以放入。

  38 mod 7 = 3，未发生冲突，直接放入。

  21 mod 7 = 0，发生冲突，按照上如方法继续探测至地址空间5。

  ### 链地址法

  HashMap使用的解决哈希冲突的策略就是链地址法。

  链地址法将具有相同hash的记录存储在同一线性链表中。

   ![图片](https://github.com/UMRhamster/Jobs2018/raw/master/source_analyze/img/hash_table_chaining.png)

* 拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；
* 由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；

  