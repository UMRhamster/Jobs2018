>参考《计算机操作系统教程（第3版）》

* [一、绪论](#1)
  - [操作系统概念](#1.1)
  - [操作系统功能](#1.2)
* [二、操作系统用户界面](#2)
  - [简介](#2.1)
  - [系统调用](#2.2)
* [三、进程管理](#3)
  - [并行与并发](#3.1)
  - [进程与线程](#3.2)
  - [进程状态及其转换](#3.3)
  - [互斥与同步](#3.4)
  - [死锁](#3.5)
<h1 id="1">一、绪论</h1>
<h2 id="1.1">操作系统概念</h2>
操作系统是计算机系统中的一个系统软件，他是这样一些程序模块的集合——他们管路和控制计算机系统中的硬件资源，合理地组织计算机工作流程，以便有效地利用这些资源为用户提供一个具有足够的功能、使用方便、可扩展、安全和可管理的工作环境，从而在计算机与其用户之间起到接口的作用。
<h2 id="1.2">操作系统功能</h2>

### 1. 处理器管理
解决对处理机分配调度策略、分配实施和资源回收等问题。
### 2. 存储器管理
对存储器进行分配、保护、扩充和管理。
### 3. 设备管理
通道、控制器、输入输出设备的分配和管理。

设备独立性。
### 4. 文件系统管理
信息的共享、保密和保护
### 5. 用户接口
一种用户接口是程序一级的接口，即提供一组广义指令（或称系统调用、程序请求）供用户程序和其他系统程序调用。

另一种接口是作业一级的接口，提供一组控制操作命令供用户去组织和控制自己作业的运行。

###### 写总结的时候，才发现这本书的概论是真的有问题，和后面章节的具体内容不是很对的上 ######
<h1 id="2">二、操作系统用户界面</h1>
<h2 id="2.1">简介</h2>
针对不同的用户，操作系统提供不同的用户界面，其中普通用户和管理员用户的界面是一组不同操作命令组成的集合，他们分别实现用户所要求的不同功能，为用户提供相应的服务；对编程人员提供的是一组系统调用的集合，这些系统调用允许编程人员使用操作系统和程序，开发能够满足用户服务需求的新的控制命令。
<h2 id="2.2">系统调用</h2>
系统调用是操作系统提供给编程人员的唯一接口。

分类：

设备管理、文件管理、进程控制、进程通信、存储管理、线程管理
<h1 id="3">三、进程管理</h1>
<h2 id="3.1">并行与并发</h2>

### 1. 并行
一组在逻辑上互相独立的程序或程序段在执行过程中，其执行时间在客观上互相重叠。
### 2. 并发
一组程序按独立的、异步的速度执行。并行执行不等于时间上的重叠。
<h2 id="3.2">进程与线程</h2>

### 1. 进程
并发执行的程序在执行过程中分配和管理资源的基本单位。
### 2. 线程
是进程的一部分。是CPU调度的基本单位。
### 3. 区别
* 除了CPU之外，计算机内的软硬件资源的分配与线程无关，线程只能共享他所属进程的资源。
* 进程拥有一个完整的虚拟地址空间。
* 进程不依赖于线程而独立存在。
* 线程是进程的一部分，它没有自己的地址空间，它和进程内的其他线程一起共享该进程的所有资源。
<h2 id="3.3">进程状态及其转换</h2>

![图片](https://github.com/UMRhamster/Jobs2018/raw/master/operating%20system/process_status.png)
* 初始态
* 执行状态
* 等待状态：进程因等待某个事件发生而放弃处理机进入等待状态。
* 就绪状态：已经得到除了CPU之外的其它资源，只要由调度得到处理机，便可立即投入执行。
* 终止状态
<h2 id="3.4">互斥与同步</h2>

### 1. 临界区
不允许多个并发进程交叉执行的一段程序。
### 2. 进程互斥
不允许两个以上的共享该资源的并发进程同时进入临界区称为互斥。
### 3. 进程同步
异步环境下的一组并发进程，因直接制约而互相发送消息而进行互相合作、互相等待，使得各进程按一定的速度执行的过程称为进程间的同步。
### 4. 信号量
信号量管理相应临界区的共有资源，它代表可用资源实体。信号量的数值仅能由P，V原语操作改变。
* P原语操作：
  1. 信号量-1
  2. 若信号量-1后仍大于或等于零，则P原语返回，该进程继续执行。
  3. 若信号量-1后相遇零，则该进程被阻塞后与该信号量相对的队列中，然后转进程调度。
* V原语操作：
  1. 信号量+1
  2. 若相加结果大于零，V原语停止执行，该进程返回调用处，继续执行。
  3. 若相加结果小于或等于零，则从该信号的等待队列中唤醒一等待进程，然后再返回原进程继续执行或转进程调度。
#### 生产者-消费者问题
把并发进程的同步和异步问题一般化，可以得到一个抽象的一般模型，即生产者-消费者模型。

    deposit(data):
        begin
            P(avail)
            P(mutix)
            数据送入缓冲区某单元
            V(full)
            V(mutix)
        end
    
    remove(data)
        begin
            P(full)
            P(mutix)
            取缓冲区中某单元数据
            V(avail)
            V(mutix)
        end
<h2 id="3.5">死锁</h2>

各并发进程彼此互相等待对方所拥有的资源，且这些并发进程在的得到对方的资源之前不会释放自己所拥有的资源。从而造成大家想要的得到资源而又得不到资源，各并发进程不能继续向前推进的状态。

![图片](https://github.com/UMRhamster/Jobs2018/raw/master/operating%20system/deadlock.png)
### 1. 产生死锁的必要条件
* 互斥条件。并发进程所要求和占有的资源是不能同时被两个以上进程使用或操作的，进程对它所需要的资源进行排他性控制。
* 不剥夺条件。进程所获得的资源在未使用完毕之前，不能被其他进程强行剥夺，而只能由获得该资源的进程自己释放。
* 部分分配。进程每次申请它所需要的一部分资源，在等待新资源的同时，继续占用已分配到的资源。
* 环路条件。存在一种进程循环链，链中每一个进程已获得的资源同时被下一个进程所请求。
### 2. 死锁的排除方法
* 死锁预防
  
  采取某种策略，限制并发进程对资源的请求，从而破坏产生死锁的必要条件中的一个或者几个来防止发生死锁。

  （一）打破“互斥”条件

  允许进程同时访问某些资源等。

  （二）破环“不可剥夺”条件
  当进程有新的资源请求时，如果得不到满足，要先释放原先占有的资源，待以后重新申请。

  （三）破坏“部分分配”条件

  运行前（创建时），一次性分配给进程它所需的全部资源。如果某个进程所需要的全部资源得不到满足时，则不分配任何资源，此进程暂不运行。

  （四）破坏“环路等待”条件

  把系统资源按类型排序（例如打印机为1、磁带机为2、磁盘为3、等等） ，进程要按照资源的序号递增的次序提出资源申请。
* 死锁避免
  
  死锁避免可被称为动态预防，因为系统采用动态分配资源，在分配过程中预测出死锁发生的可能性并加以避免的方法。
  #### 银行家算法
  在避免死锁方法中允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次分配资源的安全性，若分配不会导致系统进入不安全状态，则分配，否则等待。

  安全序列是指一个进程序列{P1，…，Pn}是安全的，即对于每一个进程Pi(1≤i≤n），它以后尚需要的资源量不超过系统当前剩余资源量与所有进程Pj (j < i )当前占有资源量之和。（即在分配过程中，不会出现某一进程后续需要的资源量比其他所有进程及当前剩余资源量总和还大的情况）

  注：存在安全序列则系统是安全的，如果不存在则系统不安全，但不安全状态不一定引起死锁。
* 死锁检测和恢复
  
  当进程进行资源请求时死锁检测算法检查并发进程组是否构成资源的请求和保持环路。死锁的恢复方法较多。最简单的办法是终止各锁住进程，或按一定顺序中止进程序列，直至已释放到有足够的资源来完成剩下的进程时为止。另外，也可以从被锁住进程强迫剥夺资源以解除死锁。